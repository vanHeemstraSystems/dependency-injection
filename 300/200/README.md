# 200 - Dependency Inversion Principle

The DIP has a broader meaning than DI that offers ways to solve the problem, while DIP formulates the principles of creating independent software modules(units, classes so on…) that interact with each other.

In the previous paragraph we managed to “separate” the ```Engine``` class from ```Car``` with DI. At first glance, it seems that we have met the requirements of the DIP principle because we can keep the ```Engine``` and ```Car``` classes in separate files, or even modules. However, if we look at the last two implementations, we can see that in the ```Car``` class there is a link to ```Engine```, type verification (```instanceof Engine``` and ```private engine: Engine```). In fact, it is a dependency on a particular implementation, not an abstraction. In the TypeScript, as in many other object-oriented programming languages, this problem is solved using interfaces or abstract classes. Those are used for type definition purposes ```private engine type: IEngine``` So, now the types of properties of the ```Car``` class allow you to get rid of importing ```Engine``` class.

However, the current implementation of interfaces in TypeScript and of course in JavaScript is not so good as we would like to have it. Let’s start with the fact that there are no interfaces in JS at this time, and in the latest versions of TypeScript (3.4) they are not available in runtime yet. This is the reason why IoC containers in JS / TS instead of interfaces often are used string literal or Symbol as keys (token). In the next parts of the article, by the interface or token we will mean string literals or symbols that correspond to specific implementations registered in the IoC containers.
